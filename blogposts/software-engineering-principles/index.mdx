---
title: 'My software engineering principles'
date: 'Sep 19, 2024'
post_id: '12272101'
hero_image: './software-engineering-principles.jpeg'
hero_image_alt: 'Person coding a computer'
hero_image_credit_text: 'Image by freepik'
hero_image_credit_link: 'https://www.freepik.com/free-photo/programming-background-with-person-working-with-codes-computer_38669443.htm'
---

I have been asked on various ocasions what is important for me as a frontend engineer. Continous learning is certainly one of my core principles, which drove me to learn and implement features with a wide range of tools, programming languages and libraries. 
Throughout my career as a software engineer, I've had the opportunity to work on various interesting and challenging problems, from site performance to web application development.
My career progression has been closely aligned with the development of my engineering principles. I have worked as a solo full stack engineer, a freelancer, a scrum team member and in various variations of agile team implementations.

This experience taught me to think from a holistically, taking into consideration the full stack of development-from server configuration and scalability to documentation and clean code best practices.
It also reinforced the importance of specialisation. As companies grow, the layers of abstraction increase, the number of collaborators expands and having specialists in key areas becomes inevitable.

Just as no one would want a heart surgeon to perform brain surgery, creating a maintainable and successful codebase requires specialists for frontend, backend, site reliability engineering, and cybersecurity among others. 
Specialists who deeply understand their field produce code that is modular, easy to modify, and maintainable—leading to faster iterations and fewer bugs.

At the end of the day, code should serve a business goal. In dynamic busines environments requirements change frequently, therefore code must be easily adaptable. To achieve this we need to reduce the cognitive load on the developers.
This brings me to another principle I value: simplicity. KISS (Keep It Simple, Stupid) and YAGNI (You Aren’t Gonna Need It) are essential guidelines. Be prepared to change your mind and avoid attachment to solutions, frameworks, or ideas. 
As renowned investor Charlie Munger once said, “We all are learning, modifying, or destroying ideas all the time. Rapid destruction of your ideas when the time is right is one of the most valuable qualities you can acquire.”

Keep an open mind, keep things simple, reduce complexity as much as possible and manage what remains. 

Balancing speed with a reliance on abstractions and third-party providers is crucial. We should avoid vendor lock-in or rigid mindsets. One of the best ways to achieve this is by focusing on fundamentals and established technologies. 
Cutting-edge tools should only be adopted when there is a clear benefit or necessity. Like in the airline industry, iterations on proven models tend to be the safest and most reliable.

The vast majority of complexity in software engineering doesn’t arise from technical challenges but from business-related problems: understanding requirements, coordinating with a large team of diverse engineers, and working within complex problem domains. 
Therefore, one of the most important responsibilities for a senior software engineer is to understand the business goals, engage with stakeholders, and ensure that the time and effort invested lead to the desired outcomes.

In team settings, communication should be clear, direct, respectful, and well-organized, while also allowing freedom and creativity. It’s only in a safe environment that the best ideas can emerge and flourish.

To summarize: continuous learning, field expertise, strong fundamentals, managing complexity, understanding business goals, and fostering team dynamics are key to thriving as a successful engineer today.